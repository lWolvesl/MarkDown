# Redis高级

## 一、数据一致性

### 1.1 如何保证数据库和Redis的数据一致性

-   eg：

![941637564521_.pic_hd](https://typroa-wolves.oss-cn-hangzhou.aliyuncs.com/img-li/941637564521_.pic_hd.jpg)

-   
    -   删除缓存
    -   更新数据库
    -   休眠200ms
    -   再删除缓存

###  1.2 双写一致性

-   四种策略
    -   先更新缓存，再更新数据库
        -   如果缓存更新成功，数据库更新失败，会造成脏数据
    -   先更新数据库，再更新缓存
        -   类似于事务丢失，并发时A先于B修改数据库，A先修改数据库，B再修改，此时若B先修改了缓存，A再修改缓存时会导致B修改失效。
    -   先删除缓存，再更新数据库
        -   并发A先于B，A先删除了缓存，还未修改数据库时B读取缓存失败而读取数据库，此时B读到的是过时的数据，再将过时数据写入缓存，导致缓存数据和数据库数据不一致
        -   为解决上述情况，即使用1.1的延迟双删，更新完数据库后再删一次缓存，延迟时间>一次读操作的时间。
    -   先更新数据库，再删除缓存
        -   A先读取缓存未命中读取数据库，此时B更新数据库并删除缓存中的数据，而A将读到的旧值写入缓存，此时双写一致。概率低：写操作耗时>读操作
        -   使用延迟双删，写入数据库并删缓存后过一段时间再删一次缓存，但是仍旧有删除失败的情况，可以使用多次删除，设置最大次数并设置报错

## 二、布隆过滤器

-   解决缓存穿透

-   默认布隆过滤器-一个很长的二进制向量
    -   ![951637567747_.pic_hd](https://typroa-wolves.oss-cn-hangzhou.aliyuncs.com/img-li/951637567747_.pic_hd.jpg)
    -   根据下标判断，如果存在就是1，如果不存在就是0

![961637567816_.pic_hd](https://typroa-wolves.oss-cn-hangzhou.aliyuncs.com/img-li/961637567816_.pic_hd.jpg)

-   当一个key进入时会使用多个hash函数（类取余）
-   删除操作困难：由于hash冲突
-   优点：
    -   一串二进制数组，占用内存小
    -   插入和查询快
    -   保密性好，不存储原始数据
-   缺点；
    -   很难做删除操作
    -   存在误判 
-   API
    -   谷歌的[Guava](https://mvnrepository.com/artifact/com.google.guava/guava)工具类中含有布隆过滤器
-   设置误判率之后会增加计算hash的次数
-   redis实现

![971637569711_.pic_hd](https://typroa-wolves.oss-cn-hangzhou.aliyuncs.com/img-li/971637569711_.pic_hd.jpg)